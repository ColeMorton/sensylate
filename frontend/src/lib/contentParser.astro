---
import {
  getCollection,
  type CollectionEntry,
  type CollectionKey,
} from "astro:content";

type PageData = {
  title: string;
  meta_title?: string;
  description?: string;
  image?: string;
  draft?: boolean;
};

export const getSinglePage = async <C extends CollectionKey>(
  collectionName: C,
): Promise<CollectionEntry<C>[]> => {
  const maxAttempts = 3;
  
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      console.log(`üîç [CONTENT] Loading ${collectionName} collection (attempt ${attempt}/${maxAttempts})...`);
      const startTime = Date.now();
      
      const allPages = await getCollection(collectionName);
      
      if (!allPages) {
        throw new Error(`Collection ${collectionName} returned null/undefined`);
      }
      
      if (!Array.isArray(allPages)) {
        throw new Error(`Collection ${collectionName} is not an array: ${typeof allPages}`);
      }

      const removeIndex = allPages.filter((data) => {
        if (!data || !data.id) {
          console.warn(`‚ö†Ô∏è [CONTENT] Invalid entry in ${collectionName}:`, data);
          return false;
        }
        return data.id.match(/^(?!-)/);
      });

      const removeDrafts = removeIndex.filter((data) => {
        if (!data || !data.data) {
          console.warn(`‚ö†Ô∏è [CONTENT] Entry missing data in ${collectionName}:`, data?.id);
          return false;
        }
        
        const pageData = data.data as PageData;
        // Show drafts in development, hide in production
        if (import.meta.env.DEV) {
          return true; // Show all posts in development
        }
        return pageData.draft !== true; // Hide drafts in production
      });

      const loadTime = Date.now() - startTime;
      console.log(`‚úÖ [CONTENT] Loaded ${removeDrafts.length} entries from ${collectionName} in ${loadTime}ms`);

      return removeDrafts;
      
    } catch (error) {
      console.error(`üí• [CONTENT ERROR] Attempt ${attempt}/${maxAttempts} failed for ${collectionName}:`, error);
      
      if (attempt < maxAttempts) {
        // Wait before retry
        const delay = attempt * 1000; // 1s, 2s, 3s...
        console.log(`‚è≥ [RETRY] Waiting ${delay}ms before retry...`);
        await new Promise(resolve => setTimeout(resolve, delay));
        continue;
      }
      
      // All attempts failed - fail fast with meaningful error
      throw new Error(`Content loading failed for collection '${collectionName}' after ${maxAttempts} attempts: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  // This should never be reached, but TypeScript requires it
  throw new Error(`Unexpected error in getSinglePage for ${collectionName}`);
};
---
